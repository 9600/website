<%
# vim: set ft=eruby ts=2 sw=2 et ai:
%>
<p>
<i class="icon-road"></i> <strong>Track</strong>: <%= l track(item[:track]) %></br>
<i class="icon-home"></i> <strong>Room</strong>: <%= l room(item[:room]) %></br>
<i class="icon-calendar"></i> <strong>Day</strong>: <%= l day(item[:day]) %></br>
<i class="icon-play"></i> <strong>Start</strong>: <%= ltt item[:day], item[:start_time] %></br>
<i class="icon-stop"></i> <strong>End</strong>: <%= ltt item[:day], item[:start_time] %>
</p>

<br style="clear: both;"/>

<% if item[:abstract] or item[:description] %>
<div class="event-blurb">
<% if item[:abstract] %>
<div class="event-abstract"><%= item[:abstract] %></div>
<% end %>
<% if item[:description] %>
<div class="event-description"><%= item[:description] %></div>
<% end %>
</div>
<% end %>

<%
  videos = []
  videos.push *((item[:attachments] or []).select{|a| a[:mime] == 'video/webm'}.map{|a| $attachments_by_export[a[:filename]][:localname]})
  videos.push *((item[:links] or []).select{|l| l[:url] =~ /\.webm$/}.map{|l| l[:url]})
  videos
  .each do |video|
    mime = case video
           when /\.webm$/
             'video/webm; codecs="vp8, vorbis"'
           when /\.og[gv]$/
             'video/ogg; codecs="theora, vorbis"'
           when /\.(mp4|mpeg)$/
             'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
           else
             next
           end

    if false
      # hack workaround that plays together with the .htaccess in
      # /var/www/video.fosdem.org
      # on achanes.fosdem.org, as our video mirrors *STILL* haven't
      # fixed their Content-Type (MIME type configuration) to
      # send back video/webm for .webm files -- not doing so
      # makes it impossible for HTML5 videos to play in the browser;
      # passing ?nomirror in the URI bypasses the automatic mirror
      # redirection on video.fosdem.org:
      url = case video
            when %r{^https?://video\.fosdem\.org\/}
              video + '?nomirror'
            else
              video
            end
    else
      url = video
    end
%>
<div class="video">
  <video src="<%= url %>" type='#{mime}'>
    <div class="alert alert-info">
      Video tag not supported. Download the video <a href="<%= video %>">here</a>.
    </div>
  </video>
</div>
<% end %>

<% unless item[:speakers].empty? %>
<h3>Speakers</h3>
<table>
    <tbody>
        <% item[:speakers].map(&$to_speaker).each do |s| %>
        <tr>
            <% photo = s[:thumbnail] ? $item_by_id.fetch("/photos/thumbnail/#{s[:thumbnail][:slug]}/") : nil%>
            <td><% if photo %><a href="<%= speaker(s).path %>"><img class="thumb" height="<%= s[:thumbnail].fetch(:height) %>" width="<%= s[:thumbnail].fetch(:width) %>" src="<%= photo.path %>"/></a><% end %></td>
            <td><%= l s %></td>
        </tr>
        <% end %>
    </tbody>
</table>
<% end %>

<% if item[:attachments] and not item[:attachments].empty? %>
  <h3>Attachments</h3>
  <ul class="event-attachments unstyled">
    <%
      item[:attachments].each do |a|
        ai = $attachments_by_export[a[:filename]]
        raise "failed to find attachment item for export name #{a[:filename]}" unless ai
        title = a[:title] ? a[:title] : ai[:title]
        icon = case ai[:media]
               when 'slides'
                 'list'
               when 'video'
                 'facetime-video'
               when 'audio'
                 'music'
               when 'paper'
                 'book'
               else
                 'download'
               end
      %>
      <li><i class="icon-<%= icon %>"></i> <a href="attachments/<%= ai[:localname] %>"><%= title %> (<%= ai[:media] %>)</a></li>
    <% end %>
  </ul>
<% end %>

<% unless item[:links].empty? %>
  <h3>Links</h3>
  <ul>
    <% item[:links].each do |l| %>
      <li><a href="<%= l[:url] %>"><%= l[:title] %></a></li>
    <% end %>
  </ul>
<% end %>

<%
if false
  table = $timetable.fetch(item[:day]).fetch(:by_index)
  interval = $timetable.fetch(item[:day]).fetch(:interval)

  unslug = lambda{|slug| slug == item[:slug]}
  sort = lambda{|e| [e[:start_time], e[:end_time], e[:room_rank], e[:conference_room_id]]}

  concurrent_events = begin
                        require 'set'
                        s = Set.new
                        (item[:start_time_index]..item[:end_time_index]).each do |i|
                          table[i].each do |slug|
                            s << slug
                          end
                        end
                        s.reject(&unslug).map(&$to_event).sort_by(&sort)
                      end

  next_up_minutes = 30
  next_up = begin
              require 'set'
              (item[:end_time_index]..item[:end_time_index] + (next_up_minutes / interval)).each do |i|
                (table[i] or []).each do |slug|
                  s << slug
                end
              end
              s.reject(&unslug).map(&$to_event).sort_by(&sort)
            end

  next_in_same_room_limit = 3
  next_in_same_room = begin
                        require 'set'
                        list = room(item[:room])[:events_by_day].fetch(item[:day].to_sym)
                        i = 0
                        while i < list.size
                          break if list[i] == item[:slug]
                          i += 1
                        end
                        raise "failed to find the event item in the list of events in the same room" unless i < list.size
                        list[(i+1)..(i+next_in_same_room_limit)].map(&$to_event)
                      end

  [
    ['sametime', "Concurrent events", concurrent_events],
    ['sameroom', "Next (up to #{next_in_same_room_limit}) talks in the same room (#{@item[:room_name]})", next_in_same_room],
    ['upcoming', "Events that start after this one (within #{next_up_minutes} minutes)", next_up],
  ].each do |anchor, heading, event_list|
      unless event_list.empty?
    %>
<a name="<%= anchor %>"></a><h3><%= heading %>:</h3>
<table class="table table-striped table-bordered table-condensed">
    <thead>
        <th>When</th>
        <th>Title</th>
        <th>Track</th>
        <th>Where</th>
    </thead>
    <tbody>
        <% event_list.each do |e| %>
        <tr>
            <td><%= e[:start_time] %>-<%= e[:end_time] %></td>
            <td><%= l(e) %></td>
            <td><%= l(track(e[:track])) %></td>
            <td><%= l(room(e[:room])) %></td>
        </tr>
        <% end %>
    </tbody>
</table>
<% end %>
<% end %>
<% end %>
