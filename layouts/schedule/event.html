<dl class="dl-horizontal well">
    <dt>Track:</dt>
    <dd><%= l track(item[:track]) %></dd>
    <dt>Room:</dt>
    <dd><%= l room(item[:room]) %></dd>
    <dt>Day:</dt>
    <dd><%= l day(item[:day]) %></dd>
    <dt>Start:</dt>
    <dd><%= ltt item[:day], item[:start_time] %></dd>
    <dt>End:</dt>
    <dd><%= ltt item[:day], item[:end_time] %></dd>
</dl>

<% if item[:abstract] %><%= item[:abstract] %><% end %>
<% if item[:description] %><%= item[:description] %><% end %>

<% unless item[:speakers].empty? %>
<h3>Speakers</h3>
<table>
    <tbody>
        <% item[:speakers].map(&$to_speaker).each do |s| %>
        <tr>
            <% photo = s[:thumbnail] ? $item_by_id.fetch("/photos/thumbnail/#{s[:thumbnail][:slug]}/") : nil%>
            <td><% if photo %><%= l s %><img height="<%= s[:thumbnail]['height'] %>" width="<%= s[:thumbnail]['width'] %>" src="<%= photo.path %>"/></a><% end %></td>
            <td><%= l s %></td>
        </tr>
        <% end %>
    </tbody>
</table>
<% end %>

<% unless item[:links].empty? %>
<h3>Links</h3>
<ul>
    <% item[:links].each do |l| %>
    <li><a href="<%= l[:url] %>"><%= l[:title] %></a></li>
    <% end %>
</ul>
<% end %>

<%
  table = $timetable.fetch(item[:day]).fetch(:by_index)
  interval = $timetable.fetch(item[:day]).fetch(:interval)

  unslug = lambda{|slug| slug == item[:slug]}
  sort = lambda{|e| [e[:start_time], e[:end_time], e[:room_rank], e[:conference_room_id]]}

  concurrent_events = begin
                        require 'set'
                        s = Set.new
                        (item[:start_time_index]..item[:end_time_index]).each do |i|
                          table[i].each do |slug|
                            s << slug
                          end
                        end
                        s.reject(&unslug).map(&$to_event).sort_by(&sort)
                      end

  next_up_minutes = 30
  next_up = begin
              require 'set'
              (item[:end_time_index]..item[:end_time_index] + (next_up_minutes / interval)).each do |i|
                (table[i] or []).each do |slug|
                  s << slug
                end
              end
              s.reject(&unslug).map(&$to_event).sort_by(&sort)
            end

  next_in_same_room_limit = 3
  next_in_same_room = begin
                        require 'set'
                        list = room(item[:room])[:events_by_day].fetch(item[:day].to_sym)
                        i = 0
                        while i < list.size
                          break if list[i] == item[:slug]
                          i += 1
                        end
                        raise "failed to find the event item in the list of events in the same room" unless i < list.size
                        list[(i+1)..(i+next_in_same_room_limit)].map(&$to_event)
                      end

  [
    ['sametime', "Concurrent events", concurrent_events],
    ['sameroom', "Next (up to #{next_in_same_room_limit}) talks in the same room (#{@item[:room_name]})", next_in_same_room],
    ['upcoming', "Events that start after this one (within #{next_up_minutes} minutes)", next_up],
  ].each do |anchor, heading, event_list|
      unless event_list.empty?
    %>
<a name="<%= anchor %>"></a><h3><%= heading %>:</h3>
<table class="table table-striped table-bordered table-condensed">
    <thead>
        <th>When</th>
        <th>Title</th>
        <th>Track</th>
        <th>Where</th>
    </thead>
    <tbody>
        <% event_list.each do |e| %>
        <tr>
            <td><%= e[:start_time] %>-<%= e[:end_time] %></td>
            <td><%= l(e) %></td>
            <td><%= l(track(e[:track])) %></td>
            <td><%= l(room(e[:room])) %></td>
        </tr>
        <% end %>
    </tbody>
</table>
<% end %>
<% end %>
