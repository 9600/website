<%
# vim: set ts=2 sw=2 et ai ft=ruby:

def schedule_table(conference, events)
  table = {}
  timeslot_duration = Time.parse(conference[:timeslot_duration])
  timeslot_seconds = timeslot_duration.hour * 3600 + timeslot_duration.min * 60
  slots_per_day = ( 24 * 60 * 60 ) / timeslot_seconds
  # create an array for each day
  days = [@item]
  days.each do | d | table[d[:title]] = [] end
  # fill array with times
  offset = 0 #conference.day_change.hour * 3600
  table.each do | day, day_table |
    current = 0
    while current < 24 * 60 * 60
      table[day].push( { 0 => sprintf("%02d:%02d", ((current+offset)/3600)%24, (current%3600)/60 ) } )
      current += timeslot_seconds
    end
  end
  events.each do | event |
    duration = Time.parse(event[:duration])
    slots = (duration.hour * 3600 + duration.min * 60)/timeslot_seconds
    start_offset = 0 #Time.parse(event.start_offset)
    #start_slot = (start_offset.hour * 3600 + start_offset.min * 60) / timeslot_seconds
    start_slot = 0
    event_day = @item
    next if table[event_day[:title]].nil?
    next if table[event_day[:title]][start_slot][event[:room]]
    table[event_day[:title]][start_slot][event[:room]] = {:event_id => event[:event_id], :slug => event[:slug], track: event[:track], track_name: event[:track_name], start_time: event[:start_time], end_time: event[:end_time], :slots => slots, title: event[:title]}
    event_date = event_day[:conference_day]
    slots.times do | i |
      next if i < 1
      day = (event_date + (start_slot + i)/slots_per_day).to_date
      slot = (start_slot + i)%slots_per_day

      ## skip processing if the events spans into days not part of the schedule
      next if not table[day.strftime('%A')]

      if (start_slot + i)%slots_per_day == 0
        # new day has started => enter event structure again
        table[day.strftime('%A')][slot][event[:room]] = {:event_id => event[:event_id], :slug => event[:slug], track: event[:track], track_name: event[:track_name], start_time: event[:start_time], end_time: event[:end_time], :slots => slots - i, title: event[:title]}
      else
        table[day.strftime('%A')][slot][event[:room]] = 0
      end

    end
  end
  # remove unused rows at the beginning and the end
  table.each do | day, day_table |
    while day_table.first && day_table.first.length == 1
      day_table.delete(day_table.first)
    end
    while day_table.last && day_table.last.length == 1
      day_table.delete(day_table.last)
    end
  end
  table
end

require 'builder'
buffer = ''
xml = Builder::XmlMarkup.new(:target => buffer, :indent => 2)

rooms = @items.select{|i| i.identifier =~ %r{^/schedule/room/.+}}
events = @items.select{|i| i.identifier =~ %r{^/schedule/event/.+}}
conference = $item_by_id.fetch("/schedule/conference/")

grid_max_columns = 7
grid_max_title_length = 25

roomranges = []
grid_rooms = rooms.reject{|r| r[:events].empty?}
(grid_rooms.length.to_f / grid_max_columns).ceil.times { | t | roomranges << (t * grid_max_columns .. ((t + 1) * grid_max_columns) - 1) }
tdwidth = 100.0 / grid_max_columns
max_title = grid_max_title_length
grid_events = events

confdays = [ item ]
page_title = "Schedule grid for #{item[:title]}"
day_header = false

xml.div(:id=>'schedule-grid',:class=>'section') do
  big_table = schedule_table(conference, grid_events)

  xml.table do
    xml.tbody do
      d = 0
      confdays.each do |day|
        d += 1
        table = big_table[day[:name]]

        i = 0
        roomranges.each do |roomrange|
          xml.tr() do
            xml.th(:class=>'time')
            i = 0
            r = grid_max_columns
            grid_rooms.each do |room|
              if roomrange.member?(i) then
                r -= 1
                xml.th(:class=>'room', :width=>"#{tdwidth}%") do
                  xml.a(room[:title], :href=>"/schedule/room/#{room[:slug]}/")
                end
              end
              i += 1
            end
            if r > 0 then
              (1 .. r).each do
                xml.th(:class=>'room', :width=>"#{tdwidth}%") do
                  xml << "&nbsp;"
                end
              end
            end
          end

          rowpos = 0
          rowindex = -1
          c = 0
          table.each do |row|
            rowpos += 1
            rowindex += 1
            c += 1
            c %= 2

            trclass = (c == 0) ? "odd" : "even"
            trclass += " hour" if (rowpos > 1 && row[0][3..5] == "00")
            xml.tr(:class => trclass) do
              xml.td(row[0],{:class=>"time"})

              j = 0
              r = grid_max_columns

              grid_rooms.each do |room|
                j += 1
                cell = row[room[:slug]]
                r -= 1 if ((cell == 0 or (cell and cell[:ltskip])) and roomrange.member?(j - 1))
                next if (cell == 0) or (cell and cell[:ltskip])

                if roomrange.member?(j - 1) then
                  r -= 1
                  if cell.nil?
                    xml.td(:class=>'room empty') do
                      xml << "&nbsp;"
                    end
                  else
                    #event = $event_by_id[row[room.conference_room_id][:event_id]]
                    slots = cell[:slots]

                    tdclass = "room event"
                    cellid = "event-#{cell[:event_id]}"

                    #speakers = ($event_speakers[event.event_id] or []).map{|x| l(x)}.join(" ")

                    title = cell[:title]
                    track_tag = '' #event.conference_track.urlify
                    link = "/schedule/event/#{cell[:slug]}/"
                    detail = nil
                    #timespec = "#{event.start_time.strftime('%H:%M')}-#{(event.start_time + Time.parse(event.duration)).strftime('%H:%M')}"
                    timespec = "#{cell[:start_time]}-#{cell[:end_time]}"

                    trackdisp = cell[:track_name]
                    if trackdisp.length > max_title then
                      trackdisp = trackdisp[0, max_title] + "…"
                    end

                    #tdclass += " track-#{track_tag}"
                    tdclass += " track"

                    if title.length > max_title then
                      longtitle = title
                      if timespec then
                        title += "\n" + timespec
                      end
                      title = title[0, max_title] + "…"
                    else
                      if timespec then
                        longtitle = timespec
                      else
                        longtitle = nil
                      end
                    end

                    xml.td({:rowspan=>slots,
                             :class=>tdclass,
                             :id=>cellid}) do
                      xml.p() do
                        if longtitle then
                          xml.a(title, {:href=>link, :title=>longtitle})
                        else
                          xml.a(title, {:href=>link})
                        end
                      end
                    end #td
                  end #if
                end #if in range

              end #rooms

              if r > 0 then
                  (1 .. r).each do
                  xml.td(:class=>'room empty', :width=>"#{tdwidth}%") do
                    xml << "&nbsp;"
                  end
                end
              end
              
            end #tr
          end #table->row

        end #roomrage

      end #conference.days
    end #tbody
  end #table
end
%>
<%= buffer %>

