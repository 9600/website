#!/usr/bin/env ruby
# vim: set ts=2 sw=2 et ai ft=ruby:

#
# fosdem.org nanoc configuration
#
# Original version: 2012-06-05 by Pascal Bleser <loki@fosdem.org>
# Questions -> loki@fosdem.org
# Documentation -> http://nanoc.stoneship.org/docs/
#

##### PREPROCESSING
preprocess do
  # clone items that have "aliases: foo, bar, spam" in their metadata
  make_aliases

  # create /headline/... items from content/news/*
  make_headlines

  # auto-set the title of content/interviews/*
  decorate_interviews

  # performance hack:
  # All the schedule/ pages have the same navigation and, hence, we're going
  # to create a single item where it is rendered once
  # (see content/schedule_navigation.erb)
  # and cache the reference to that item using a global variable
  # $schedule_navigation_item to also avoid having to run through
  # all items to find it.
  # That $schedule_navigation_item is referenced and used in
  # layouts/default.html
  $schedule_navigation_item = @items.select{|item| item.identifier == '/schedule_navigation/'}.first
  raise "failed to find an item with the identifier /schedule_navigation/" unless $schedule_navigation_item

  # and the same for the sponsors block
  # (this optimization actually reduces rendering time from 4min to 30sec)
  $sponsors_navigation_item = @items.select{|item| item.identifier == '/sponsors_navigation/'}.first
  raise "failed to find an item with the identifier /sponsors_navigation/" unless $sponsors_navigation_item

end

##### COMPILING

compile '/static/*' do; end

# skip those, as they are combined into content/assets/style/fosdem.css
compile '/assets/style/parts/*' do;end
route '/assets/style/parts/*' do;end

compile '/assets/style/*' do
  # merge all content/assets/style/parts/*.css files into one
  # in content/assets/style/*.css (see the ERB/ruby code there)
  # in order to optimize web browser performance (less HTTP
  # round-trips), see
  # http://userprimary.net/posts/2011/01/10/optimizing-nanoc-based-websites/
  # for inspiration

  # process those using ERB:
  filter :erb
  # then relativize any resource paths (to images and such):
  filter :relativize_paths, :type => :css
  # minimize CSS files:
  filter :rainpress
end

# don't apply any filters on the headlines/* items as they are already
# rendered by the "make_headlines" helper at preprocessing stage
# (they do not exist in the filesystem under content/ -- instead, they
# are items that are created on-the-fly as headlines from content/news/*)
compile '/headlines/*' do;end

compile '*' do
  if item.binary?
    # donâ€™t filter binary items
  else
    # process <% ERB %> templating
    # http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html
    filter :erb

    # only run the chain of filters when it's not an .xml or .erb file
    unless ['xml', 'erb'].include? item[:extension] then

      unless item.identifier =~ %r{^/schedule/} or item[:kind] == 'internal'

        # convert .md and .markdown files to HTML using the
        # kramdown processor
        filter :kramdown if ['markdown', 'md'].include? item[:extension]

        # run the custom interview filter (lib/helpers/interview_filter.rb)
        # on content/interviews/* -- it adds a CC license footer and
        # converts "Q: ..." lines to styled HTML markup
        filter :interview if item.interview?

        # do the same as above for items that have "qa: true" in their
        # metadata, but without adding the license footer
        filter :interview, {:nolicense => true} if item[:filter] == 'qa'

        # run the custom news filter (lib/filters/news_filter.rb) on
        # content/news/* -- it removes "---MORE---" lines and removes
        # from the beginning of the content until "---FULL---" lines
        # (analog to the make_headlines function from lib/helpers/news.rb
        # which does the "opposite" (kindof) to generate headline items)
        filter :news if item.news?

        # run the custom pagelinks filter (lib/filters/pagelinks.rb) on
        # all items to replace page:... URLs with their actual URLs as
        # they will be rendered
        filter :pagelinks

        # run the custom assetlinks filter (lib/filters/assetlinks.rb)
        # on all items to replace asset:... URLs with their actual URLs
        # as they will be rendered
        filter :assetlinks

        # run the custom schedulelinks filter (lib/filters/schedulelinks.rb)
        # on all items to replace speaker:..., event:... and track:...
        # URLs with their actual URLs as they will be rendered, including
        # e.g. speaker:2012/foobar that will point to archive.fosdem.org/...
        filter :schedulelinks

        # retrieve the image width and height from the image files that
        # are referenced in <img/> tags to speed up browser rendering
        # performance, see
        # http://userprimary.net/posts/2011/01/10/optimizing-nanoc-based-websites/
        # for inspiration, as well as
        # https://developers.google.com/speed/docs/best-practices/rendering#SpecifyImageDimensions
        filter :imagesize
      end

      # transform absolute paths in URLs with relative paths using the
      # relativize_paths filter (that is shipped with nanoc)
      # *** OPTIMIZATION: don't use it as of now, wins a few seconds ***
      #filter :relativize_paths, :type => :xhtml unless item[:relativize] == false

      # use layout/default.html for all items, except
      # sponsor pages and pages that have "layout: false"
      # in their metadata
      layout 'default' unless item.sponsor? or item[:layout] == false
    end
  end
end

##### ROUTING

# send this one into oblivion, its compiled content is included in
# layouts/default.html, but is not to be rendered as a file of its
# own into output
route '/schedule_navigation/' do;end
route '/sponsors_navigation/' do;end

route '/static/*' do
  # /static/foo.html/ -> /foo.html
  item.identifier[7..-2]
end

# route /headlines/* into oblivion as they don't really exist on
# the site (and are not supposed to): they are created dynamically
# during preprocessing stage (by the "make_headlines" function that's
# defined in lib/helpers/news.rb) and only intended to be gathered
# in content/index.html
route '/headlines/*/' do;end

# deploy content/assets/style/foo.css as output/assets/style/foo.css
# (without this, nanoc would deploy it as output/assets/style/foo/index.html)
route '/assets/*/' do
  suffix = if @site.config[:digest_assets] then
             require 'digest/sha2'
             sha = Digest::SHA256.new
             if item.binary? then
               sha << IO.read(item[:filename])
             else
               sha << item.raw_content
             end
             digest = sha.hexdigest.downcase
             "-#{digest}"
           else
             ""
           end
  "#{item.identifier.chop}#{suffix}.#{item[:extension]}"
end

# do _not_ deploy the files under content/sponsors/ as they are only used
# programatically in content/about/sponsors.html, but we _do_ want to
# deploy binary files (typically the sponsor logos) that are under
# content/sponsors/, hence the "if item.binary?"
route '/sponsors/*/' do
  if item.binary?
    if item.identifier =~ %r{^(.+)/(.+?)-(big|small)/$} then
      name = $2
      size = $3
      suffix = if @site.config[:digest_sponsor_logos] then
                 require 'digest/sha2'
                 sha = Digest::SHA256.new
                 sha << IO.read(item[:filename])
                 digest = sha.hexdigest.downcase
                 "-#{digest}"
               else
                 ""
               end

      case size
      when 'big'
        # big logos: /sponsored-by/google.png
        "/sponsored-by/#{name}#{suffix}.#{item[:extension]}"
      when 'small'
        # small logos: /sponsored-by/thumb/oreilly.png
        "/sponsored-by/thumb/#{name}#{suffix}.#{item[:extension]}"
      else
        raise "wtf?"
      end
    else
      "/sponsored-by/#{item.id}.#{item[:extension]}"
    end
  else
    # do nothing with the non-binary files
  end
end

route '*' do
  if item.binary?
    # Write binary item with identifier /foo/ to /foo.ext
    item.identifier.chop + '.' + item[:extension]
  elsif item[:extension] == 'xml'
    # Write XML files with identifier /foo/ to /foo.xml
    item.identifier.chop + '.' + item[:extension]
  else
    # Write text item with identifier /foo/ to /foo/index.html
    item.identifier + 'index.html'
  end
end

##### LAYOUT PROCESSING
layout '*', :erb
