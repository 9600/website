#!/usr/bin/env ruby
# vim: set ts=2 sw=2 et ai ft=ruby:

#
# fosdem.org nanoc configuration
#
# Original version: 2012-06-05 by Pascal Bleser <loki@fosdem.org>
# Questions -> loki@fosdem.org
# Documentation -> http://nanoc.stoneship.org/docs/
#

##### PREPROCESSING
preprocess do

  # clone items that have "aliases: foo, bar, spam" in their metadata
  make_aliases

  # create /headline/... items from content/news/*
  make_headlines

  # auto-set the title of content/interviews/*
  decorate_interviews

  # build a global hash of items by their identifier, much faster for lookups
  # than having to run over all of them; needs to be a global variable
  $item_by_id = {}
  @items.each do |item|
    raise "duplicate identifier #{item.identifier}" if $item_by_id.has_key? item.identifier
    $item_by_id[item.identifier] = item
  end

  # performance hack:
  # All the schedule/ pages have the same navigation and, hence, we're going
  # to create a single item where it is rendered once
  # (see content/schedule_navigation.erb)
  # and cache the reference to that item using a global variable
  # $schedule_navigation_item to also avoid having to run through
  # all items to find it.
  # That $schedule_navigation_item is referenced and used in
  # layouts/default.html
  $schedule_navigation_item = $item_by_id.fetch('/schedule_navigation/')

  # and the same for the sponsors block
  # (this optimization actually reduces rendering time from 4min to 30sec)
  $sponsors_navigation_item = $item_by_id.fetch('/sponsors_navigation/')

end

##### COMPILING

compile '/internal/*' do;end

# skip those, as they are combined into content/assets/style/fosdem.css
compile '/assets/style/parts/*' do;end
route '/assets/style/parts/*' do;end

compile '/navigation/' do;end
route '/navigation/' do;end

compile '/assets/style/*' do
  # merge all content/assets/style/parts/*.css files into one
  # in content/assets/style/*.css (see the ERB/ruby code there)
  # in order to optimize web browser performance (less HTTP
  # round-trips), see
  # http://userprimary.net/posts/2011/01/10/optimizing-nanoc-based-websites/
  # for inspiration

  # process those using ERB:
  filter :erb
  # then relativize any resource paths (to images and such):
  filter :relativize_paths, :type => :css
  # minimize CSS files:
  filter :rainpress
end

# don't apply any filters on the headlines/* items as they are already
# rendered by the "make_headlines" helper at preprocessing stage
# (they do not exist in the filesystem under content/ -- instead, they
# are items that are created on-the-fly as headlines from content/news/*)
compile '/headlines/*' do;end

compile '*' do
  if item.binary?
    # donâ€™t filter binary items
  else
    # process schedule items with their respective template from layouts/schedule/
    # (e.g. /schedule/event/foo is processed with layouts/schedule/event.*)
    layout "/schedule/#{$1}/" if item.identifier =~ %r{^/schedule/([^/]+)/.+}

    # process <% ERB %> templating
    # http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html
    filter :erb

    # only run the chain of filters when it's not an .xml or .erb or .ics file
    unless ['xml', 'erb', 'ics'].include? item[:extension] then

      unless item.identifier =~ %r{^/schedule/} or item[:kind] == 'internal'

        # convert .md and .markdown files to HTML using the
        # kramdown processor
        filter :kramdown if ['markdown', 'md'].include? item[:extension]

        # run the custom interview filter (lib/helpers/interview_filter.rb)
        # on content/interviews/* -- it adds a CC license footer and
        # converts "Q: ..." lines to styled HTML markup
        filter :interview if item.interview?

        # do the same as above for items that have "qa: true" in their
        # metadata, but without adding the license footer
        filter :interview, {:nolicense => true} if item[:filter] == 'qa'

        # run the custom news filter (lib/filters/news_filter.rb) on
        # content/news/* -- it removes "---MORE---" lines and removes
        # from the beginning of the content until "---FULL---" lines
        # (analog to the make_headlines function from lib/helpers/news.rb
        # which does the "opposite" (kindof) to generate headline items)
        filter :news if item.news?

        # run the custom pagelinks filter (lib/filters/pagelinks.rb) on
        # all items to replace page:... URLs with their actual URLs as
        # they will be rendered
        filter :pagelinks

        # run the custom assetlinks filter (lib/filters/assetlinks.rb)
        # on all items to replace asset:... URLs with their actual URLs
        # as they will be rendered
        filter :assetlinks

        # run the custom schedulelinks filter (lib/filters/schedulelinks.rb)
        # on all items to replace speaker:..., event:... and track:...
        # URLs with their actual URLs as they will be rendered, including
        # e.g. speaker:2012/foobar that will point to archive.fosdem.org/...
        filter :schedulelinks

        # retrieve the image width and height from the image files that
        # are referenced in <img/> tags to speed up browser rendering
        # performance, see
        # http://userprimary.net/posts/2011/01/10/optimizing-nanoc-based-websites/
        # for inspiration, as well as
        # https://developers.google.com/speed/docs/best-practices/rendering#SpecifyImageDimensions
        filter :imagesize
      end

      # transform absolute paths in URLs with relative paths using the
      # relativize_paths filter (that is shipped with nanoc)
      # *** OPTIMIZATION: don't use it as of now, wins a few seconds ***
      #filter :relativize_paths, :type => :xhtml unless item[:relativize] == false

      # use layout/default.html for all items, except
      # sponsor pages and pages that have "layout: false"
      # in their metadata
      if item[:layout] == false or item.sponsor? or item.identifier =~ %r{/[ix]cal/}
        # do nothing
      elsif item[:layout]
        layout item[:layout]
      else
        layout 'default'
      end
    end
  end
end

##### ROUTING

route '/internal/*' do;end

# send this one into oblivion, its compiled content is included in
# layouts/default.html, but is not to be rendered as a file of its
# own into output
route '/schedule_navigation/' do;end
route '/sponsors_navigation/' do;end

route '/photos/*' do
  name, ext = if item.identifier.split('/')[-1] =~ %r{^(.+)\.(.+)$}
                [ $1, $2 ]
              else
                raise "photo item identifier is not supported: #{item.identifier.split('/')[-1]}"
              end

  suffix = if @site.config[:digest_assets] then
             require 'digest/sha2'
             sha = Digest::SHA256.new
             if item.binary? then
               sha << IO.read(item[:filename])
             else
               sha << item.raw_content
             end
             digest = sha.hexdigest.downcase
             "-#{digest}"
           else
             ""
           end

  "/schedule/speaker/#{name}#{suffix}.#{ext}"
end

route '/schedule/xcal/track/*' do
  '/schedule/track/' + item.identifier.split('/')[-1] + ".xcs"
end
route '/schedule/ical/track/*' do
  '/schedule/track/' + item.identifier.split('/')[-1] + ".ics"
end
route '/schedule/pentabarf/' do
  '/schedule/xml'
end
route '/schedule/xcal/' do
  '/schedule/xcal'
end
route '/schedule/ical/' do
  '/schedule/ical'
end

# route /headlines/* into oblivion as they don't really exist on
# the site (and are not supposed to): they are created dynamically
# during preprocessing stage (by the "make_headlines" function that's
# defined in lib/helpers/news.rb) and only intended to be gathered
# in content/index.html
route '/headlines/*/' do;end

# deploy content/assets/style/foo.css as output/assets/style/foo.css
# (without this, nanoc would deploy it as output/assets/style/foo/index.html)
route '/assets/*/' do
  suffix = if @site.config[:digest_assets] then
             require 'digest/sha2'
             sha = Digest::SHA256.new
             if item.binary? then
               sha << IO.read(item[:filename])
             else
               sha << item.raw_content
             end
             digest = sha.hexdigest.downcase
             "-#{digest}"
           else
             ""
           end
  "#{item.identifier.chop}#{suffix}.#{item[:extension]}"
end

route %r{^/schedule/(thumbnail|photo)/speaker/} do
end

route '/schedule/speaker_thumbnails/*/' do
  suffix = if @site.config[:digest_assets] then
             require 'digest/sha2'
             sha = Digest::SHA256.new
             if item.binary? then
               sha << IO.read(item[:filename])
             else
               sha << item.raw_content
             end
             digest = sha.hexdigest.downcase
             "-#{digest}"
           else
             ""
           end
  "/schedule/speaker/#{item[:slug]}-small#{suffix}.#{item[:extension]}"
end

# do _not_ deploy the files under content/sponsors/ as they are only used
# programatically in content/about/sponsors.html, but we _do_ want to
# deploy binary files (typically the sponsor logos) that are under
# content/sponsors/, hence the "if item.binary?"
route '/sponsors/*/' do
  if item.binary?
    if item.identifier =~ %r{^(.+)/(.+?)-(big|small)/$} then
      name = $2
      size = $3
      suffix = if @site.config[:digest_sponsor_logos] then
                 require 'digest/sha2'
                 sha = Digest::SHA256.new
                 sha << IO.read(item[:filename])
                 digest = sha.hexdigest.downcase
                 "-#{digest}"
               else
                 ""
               end

      case size
      when 'big'
        # big logos: /sponsored-by/google.png
        "/sponsored-by/#{name}#{suffix}.#{item[:extension]}"
      when 'small'
        # small logos: /sponsored-by/thumb/oreilly.png
        "/sponsored-by/thumb/#{name}#{suffix}.#{item[:extension]}"
      else
        raise "wtf?"
      end
    else
      "/sponsored-by/#{item.id}.#{item[:extension]}"
    end
  else
    # do nothing with the non-binary files
  end
end

route '*' do
  if item.binary?
    # Write binary item with identifier /foo/ to /foo.ext
    item.identifier.chop + '.' + item[:extension]
  elsif item[:extension] == 'xml'
    # Write XML files with identifier /foo/ to /foo.xml
    item.identifier.chop + '.' + item[:extension]
  else
    # Write text item with identifier /foo/ to /foo/index.html
    item.identifier + 'index.html'
  end
end

##### LAYOUT PROCESSING
layout '*', :erb
