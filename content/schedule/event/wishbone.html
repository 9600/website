---
title: The Self-Describing Wishbone Bus
kind: event
speakers:
  -
    name: Manohar Vanga
    slug: manohar_vanga
    url: /schedule/speaker/manohar_vanga
slug: wishbone
track: Lightning Talks
track_url: /schedule/track/lightning_talks
track_rank: 20
room: Ferrer
room_url: /schedule/room/ferrer
day: Saturday
day_url: /schedule/day/saturday
shortday: Sat
event_id: 490
event_type: lightningtalk
start: 2012-02-04 16:40:00.000000000 +00:00
end: 2012-02-04 16:55:00.000000000 +00:00
---
<dl class="dl-horizontal">
    <dt>Track:</dt>
    <dd><a href="/schedule/track/lightning_talks">Lightning Talks</a></dd>
    <dt>Room:</dt>
    <dd><a href="/schedule/room/ferrer">Ferrer</a></dd>
    <dt>Day:</dt>
    <dd><a href="/schedule/day/saturday">Saturday</a></dd>
    <dt>Start:</dt>
    <dd>16:40</dd>
    <dt>End:</dt>
    <dd>16:55</dd>
</dl>

<p>The Wishbone bus is an open source hardware computer bus specification intended to let different logic blocks within an integrated circuit communicate with each other. This talk will introduce a set of memory mapped data structures that allow designers to describe their own logic blocks, thus allowing for the auto-discovery of devices on a Wishbone bus.</p>
<p>The Wishbone bus is an open source hardware computer bus intended to let different logic blocks within an integrated circuit communicate with each other. This talk will introduce a set of memory mapped data structures that allow designers to describe their own logic blocks.  Thus, for compliant chip designs, the operating system can enumerate the Wishbone bus inside the integrated circuits and load the appropriate drivers, similar to PCI or USB. The proposed specification is already being used in a set of FPGA based cards being developed at the Open Hardware Repository. By defining a new bus type within the Linux kernel, the driver for each board can register as a Wishbone controller and benefit from automatic enumeration.  The bus controller can use the information it retrieves to load or activate the appropriate set of drivers to manage either the whole board or the various peripherals that are attached to the internal Wishbone bus. Such a scheme greatly simplifies managing the variety of FPGA binary images, by allowing automatic division of the problem space. Even when a single driver is needed for the whole device-set within the internal bus, a standardized identification mechanism reliefs system administrators from manually matching FPGA images and software drivers.</p>

<h3>Speakers</h3>
<table>
    <tbody>
        <% @item[:speakers].each do |s| %>
        <tr>
            <% photo = $item_by_id["/schedule/speaker_thumbnails/#{s[:slug]}/"] %>
            <td><% if photo %><a href="<%= s[:url] %>"><img height="<%= photo[:height] %>" width="<%= photo[:width] %>" src="<%= photo.path %>"/></a><% end %></td>
            <td><a href="<%= s[:url] %>"><%= s[:name] %></a></td>
        </tr>
        <% end %>
    </tbody>
</table>

