---
title: Ensuring uptime in a small startup
kind: event
speakers:
  -
    name: Apostolos Bessas
    slug: apostolos_bessas
    url: /schedule/speaker/apostolos_bessas
slug: postgresql_ensuring_uptime_in_a_small_startup
track: PostgreSQL
track_url: /schedule/track/postgresql
track_rank: 506
room: K.4.201
room_url: /schedule/room/k4201
day: Saturday
day_url: /schedule/day/saturday
shortday: Sat
event_id: 669
event_type: devroom
start: 2012-02-04 11:00:00.000000000 +00:00
end: 2012-02-04 11:50:00.000000000 +00:00
links:
---
<dl class="dl-horizontal">
    <dt>Track:</dt>
    <dd><a href="/schedule/track/postgresql">PostgreSQL</a></dd>
    <dt>Room:</dt>
    <dd><a href="/schedule/room/k4201">K.4.201</a></dd>
    <dt>Day:</dt>
    <dd><a href="/schedule/day/saturday">Saturday</a></dd>
    <dt>Start:</dt>
    <dd>11:00</dd>
    <dt>End:</dt>
    <dd>11:50</dd>
</dl>

<p>Running a web application that is used by people from all over the world means that you cannot afford any downtime.
However, the codebase and the database schema constantly evolves, while at the same time hardware failures may happen.
The talk will try to present ways that we, at transifex.net, use to deal with the following two issues:
- schema changes
- hardware failures
in order to achieve 100% uptime.
The talk will discuss tools that PostgreSQL provides, like functions and triggers, and how they can be used to deal with schema changes and how to setup streaming replication for fail-over.</p>

<h3>Speakers</h3>
<table>
    <tbody>
        <% @item[:speakers].each do |s| %>
        <tr>
            <% photo = $item_by_id["/schedule/speaker_thumbnails/#{s[:slug]}/"] %>
            <td><% if photo %><a href="<%= s[:url] %>"><img height="<%= photo[:height] %>" width="<%= photo[:width] %>" src="<%= photo.path %>"/></a><% end %></td>
            <td><a href="<%= s[:url] %>"><%= s[:name] %></a></td>
        </tr>
        <% end %>
    </tbody>
</table>


